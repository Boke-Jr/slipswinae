"""
This file tests 2 different config files other than slips' default config/slips.yaml
test/test.yaml and tests/test2.yaml
"""

import re
import shutil
from pathlib import PosixPath

import redis

from tests.common_test_utils import (
    create_output_dir,
    assert_no_errors,
)
import pytest
import os
import subprocess
import time
import sys

alerts_file = "alerts.log"


def countdown(seconds, message):
    """
    counts down from the given number of seconds, printing a message each second.
    """
    while seconds > 0:
        sys.stdout.write(
            f"\rSending {message} in {seconds} "
        )  # overwrite the line
        sys.stdout.flush()  # ensures immediate output
        time.sleep(1)  # waits for 1 second
        seconds -= 1
    sys.stdout.write(f"\rSending {message} now!          \n")


def message_send(port, channel, message):
    # connect to redis database 0
    redis_client = redis.StrictRedis(host="localhost", port=port, db=0)

    # publish the message to the "network2fides" channel
    redis_client.publish(channel, message)

    print(f"Test message published to channel '{channel}'.")


message_alert_TL_NL = """{
    "type": "tl2nl_alert",
    "version": 1,
    "data": {
      "payload": "https://www.youtube.com/watch?v=dQw4w9WgXcQ"
    }
}"""


message_alert_NL_S = """{
    "type": "nl2tl_alert",
    "version": 1,
    "data":
        "sender": "<Metadata of peer who's alerting>"
        "payload": "https://www.youtube.com/watch?v=dQw4w9WgXcQ"
}"""


def check_strings_in_file(string_list, file_path):
    # Check if the file exists
    if not os.path.exists(file_path):
        print(f"File {file_path} does not exist.")
        return False

    # Open the file and read its content
    try:
        with open(file_path, "r") as file:
            file_content = file.read()

        # Check if all strings in the list are present in the file content
        for string in string_list:
            if string not in file_content:
                return False
        return True

    except Exception as e:
        print(f"Error reading file: {e}")
        return False


def prepare_configuration(cleanup=False):
    log_file = "output/integration_tests/iris_create/iris_log.txt"
    config_file = "tests/integration_tests/config/iris_peer_config.yaml"
    backup_file = config_file + ".bak"

    if not cleanup:
        # Read logfile and extract the "connection string" from it
        with open(log_file, "r") as log:
            for line in log:
                match = re.search(r"connection string:\s+'(.+)'", line)
                if match:
                    original_conn_string = match.group(1)
                    break
            else:
                print("No connection string found in log file.")
                exit(1)

        # Backup the original config file
        # to be able to run the test multiple times
        shutil.copy(config_file, backup_file)
        new_conn_string = "    -" + original_conn_string

        # Append the new connection string
        with open(config_file, "a") as config:
            config.write("\n" + new_conn_string + "\n")

        # bcuz iris is expecting the key to be there
        shutil.move("keyfile.priv", "modules/irisModule/keyfile.priv")

    else:
        shutil.move(backup_file, config_file)
        os.remove("modules/irisModule/keyfile.priv")

@pytest.mark.parametrize(
    "path, output_dir, peer_output_dir, redis_port, peer_redis_port",
    [
        (
            "dataset/test13-malicious-dhcpscan-zeek-dir",
            "iris_integration_test/",
            "peer_iris_integration_test/",
            6644,
            6655,
        )
    ],
)
def test_messaging_with_pregenerated_keys(path, output_dir, peer_output_dir, redis_port, peer_redis_port):
    """
    Tests whether Iris properly distributes an alert message generated by Slips to the network (~other peers).
    First Slips instance acts as a bootstrapping node, its connection string is set, and the second instance of Slips acts
    as a normal-user-peer that joins the network using the aforementioned Slips instance.

    In this scenario a feature of Iris where private key for a peer can be generated beforehand, keeping the connection string (P2P address)
    unchanged between the runs of a peer is tested and the message distribution acts as a proof of established connection.
    """
    output_dir: PosixPath = create_output_dir(output_dir)
    output_file = os.path.join(output_dir, "slips_output.txt")

    output_dir_peer: PosixPath = create_output_dir(peer_output_dir)
    output_file_peer = os.path.join(output_dir_peer, "slips_output.txt")

    output_dir_create: PosixPath = create_output_dir("iris_create")
    output_file_create = os.path.join(output_dir_create, "iris_log.txt")

    iris_log_entries = ["INFO	iris	protocols/alert.go:111	received p2p alert message"]
    command = [
        "./slips.py",
        "-t",
        "-g",
        "-e",
        "1",
        "-f",
        str(path),
        "-o",
        str(output_dir),
        "-c",
        "tests/integration_tests/config/slips_iris_main_config.yaml",
        "-P",
        str(redis_port),
    ]

    peer_command = [
        "./slips.py",
        "-t",
        "-g",
        "-e",
        "1",
        "-f",
        str(path),
        "-o",
        str(output_dir_peer),
        "-c",
        "tests/integration_tests/iris_config.yaml",
        "-P",
        str(peer_redis_port),
    ]

    print("running slips ...")
    #print(output_dir)

    # Define the executable and config file paths for iris key creator
    executable_path = os.path.join(".", "modules", "irisModule", "peercli")
    config_path = os.path.join("tests", "integration_tests", "config", "iris_creator_config.yaml")
    executable_path = os.path.abspath(executable_path)
    command_creator = [str(executable_path), "--conf", str(config_path)]

    with open(output_file_create, "w") as log_file:
        redis_process = subprocess.Popen(["redis-server", "--port", "6622"])
        countdown(5, "iris creator")
        creator = subprocess.Popen(command_creator, stdout=log_file, stderr=log_file)
        countdown(15, "sigterm")
        # send a SIGTERM to the process
        redis_process.terminate()
        os.kill(creator.pid, 15)
        print("SIGTERM sent. killing iris\' creator")
        redis_process.kill()
        os.kill(creator.pid, 9)

    prepare_configuration()

    # the purpose of this is to avoid hardcoding the domain of th e
    # bootsrap peer and using it
    # so the creator must create the private peer id and exchange it
    # between the 2 slips instance

    try:
        # Open the log file in write mode
        with open(output_file, "w") as log_file:
            with open(output_file_peer, "w") as iris_log_file:
                # Start the subprocess, redirecting stdout and stderr to the same file
                process = subprocess.Popen(
                    command,  # Replace with your command
                    stdout=log_file,
                    stderr=log_file,
                )

                countdown(20, "second peer")

                Pprocess = subprocess.Popen(peer_command, stdout=iris_log_file, stderr=iris_log_file)

                print(f"Output and errors are logged in {output_file}")
                countdown(80, "message")
                message_send(redis_port, message=message_alert_TL_NL, channel="fides2network",)
                # these seconds are the time we give slips to process the msg
                countdown(30, "sigterm")
                # send a SIGTERM to the process
                os.kill(process.pid, 15)
                os.kill(Pprocess.pid, 15)
                print("SIGTERM sent. killing slips + iris")
                os.kill(process.pid, 9)
                os.kill(Pprocess.pid, 9)

        print(f"Slips with PID {process.pid} was killed.")
        print(f"Slips peer wit0h PID {Pprocess.pid} was killed.")

        print("Slip is done, checking for errors in the output dir.")
        assert_no_errors(output_dir)
        assert_no_errors(output_dir_peer)
        print("Checking")
        assert check_strings_in_file(iris_log_entries, "output/iris_peer/iris_logs.txt")

        print("Deleting the output directory")
        # shutil.rmtree(output_dir)
        # shutil.rmtree(output_dir_peer)
    finally:
        prepare_configuration(cleanup=True)


@pytest.mark.parametrize(
    "zeek_dir_path, output_dir, peer_output_dir, redis_port, peer_redis_port",
    [
        (
            "dataset/test13-malicious-dhcpscan-zeek-dir",
            "iris_integration_test/",
            "peer_iris_integration_test/",
            6644,
            6655,
        )
    ],
)
def test_messaging(
    zeek_dir_path, output_dir, peer_output_dir, redis_port, peer_redis_port
):
    """
    Tests whether Iris properly distributes an alert message generated by Slips to the network (~other peers).

    First Slips instance is a general node in the network, its connection string is generated and extracted from logs as a normal user would do,
    in a very standard use case. The second instance of Slips acts as a normal-user-peer that joins the network via the aforementioned Slips instance,
    which extends the standard use case of connecting to such P2P network.
    """
    output_dir: PosixPath = create_output_dir(output_dir)
    output_file = os.path.join(output_dir, "slips_output.txt")

    output_dir_peer: PosixPath = create_output_dir(peer_output_dir)
    output_file_peer = os.path.join(output_dir_peer, "slips_output.txt")

    log_file_first_iris = "output/iris/iris_logs.txt"
    config_file = "tests/integration_tests/config/iris_peer_config.yaml"
    backup_file = config_file + ".bak"

    print("running slips ...")
    try:
        with open(output_file, "w") as log_file:
            with open(output_file_peer, "w") as iris_log_file:
                # Start the subprocess, redirecting stdout and stderr
                # to the same file
                # uses the private key  generated by the creator
                command = [
                    "./slips.py",
                    "-t",
                    "-g",
                    "-e",
                    "1",
                    "-f",
                    str(zeek_dir_path),
                    "-o",
                    str(output_dir),
                    "-c",
                    "tests/integration_tests/slips_iris_1_config.yaml",
                    "-P",
                    str(redis_port),
                ]
                process = subprocess.Popen(
                    command,
                    stdout=log_file,
                    stderr=log_file,
                )

                # First peer (its Iris) needs to be ready and available for connections when the seond peer tryes to reach out to it.
                countdown(20, "second peer")
                # get the connection string from the first peer and give it to the second one so it is reachable
                with open(log_file_first_iris, "r") as log:
                    for line in log:
                        match = re.search(r"connection string:\s+'(.+)'", line)
                        if match:
                            original_conn_string = match.group(1)
                            break
                    else:
                        print("No connection string found in log file.")
                        exit(1)

                # Backup the original config file
                # to be able to run the test multiple times
                shutil.copy(config_file, backup_file)

                # Append the new connection string
                with open(config_file, "a") as config:
                    config.write("\n    - " + original_conn_string + "\n")

                peer_command = [
                    "./slips.py",
                    "-t",
                    "-g",
                    "-e",
                    "1",
                    "-f",
                    str(zeek_dir_path),
                    "-o",
                    str(output_dir_peer),
                    "-c",
                    "tests/integration_tests/iris_config.yaml",
                    "-P",
                    str(peer_redis_port),
                ]
                peer_process = subprocess.Popen(
                    peer_command, stdout=iris_log_file, stderr=iris_log_file
                )

                print(
                    f"Output and errors of first peer are logged in"
                    f" {output_file}"
                )

                # let Slips properly and fully star with all of its parts and modules.
                countdown(80, "Sending msg in fides2network")
                message_send(
                    redis_port,
                    message=message_alert_TL_NL,
                    channel="fides2network",
                )

                # these seconds are the time we give slips to process the msg
                countdown(30, "Sending SIGTERM to the 2 peers")
                # Kill em with kindness.
                os.kill(process.pid, 15)
                os.kill(peer_process.pid, 15)
                print("SIGTERM sent.")

                print("Sending SIGKILL to the 2 instances of Slips + iris")
                # Kill em. Without kindness.
                os.kill(process.pid, 9)
                print(f"Slips with PID {process.pid} was killed.")

                os.kill(peer_process.pid, 9)
                print(f"Slips peer with PID {peer_process.pid} was killed.")

        print("Slips is done, checking for errors in the 2 output dirs.")
        assert_no_errors(output_dir)
        assert_no_errors(output_dir_peer)

        print("Checking for iris expected logs in the generated log file")
        # make sure this string is there in the generated iris logs
        # this is how we ensure that iris ran correctly
        expected_log_entry = [
            "INFO	iris	protocols/alert.go:111	received p2p alert message"
        ]
        assert check_strings_in_file(
            expected_log_entry, "output/iris_peer/iris_logs.txt"
        )

        print("Deleting the output directory")
        shutil.rmtree(output_dir)
        shutil.rmtree(output_dir_peer)
    finally:
        # This resets peer's (second Slips instance) configurations file.
        # Reproducibility of this whole test is ensured by this.
        shutil.move(backup_file, config_file)
